[{"id":1417207904666,"title":"angular随手记","content":"### 知识点1：创建服务\n\n|--factory\n\n|--service      可以返回构造函数  能通过this方法添加属性和方法\n\n|--constant   常用于返回常量  常用于创建配置数据  可以被注入配置函数（config）\n\n|--value        常用于返回常量   常用于创建对象和函数。\n\n### 知识点2 ： 添加自定义服务依赖项\n\n|--隐式指明                       压缩时注入对象可能会时效\n\n|--调用$inject属性             效率低\n\n|--显示声明 \n                    \napp.factory('ServiceName',['dep1','dep2',function(dep1,dep2){}])\n\n### 知识点3 ： 嵌套注入服务\n\n1.注入对象或服务\n\n2.将一个自定义的服务注入另外一个自定义的服务中  ----- 嵌套注入服务\n\n### 知识点4 ： 服务的装饰器 \n\n $provide.decorator('服务名',function($delegate){}）\n $delegate参数是原服务的实例\n\n### 知识点5 ： 服务的多例性\n\n1.一般 服务返回的都是一个单例对象。\n\n2.一个服务也可以在每次调用时实例化一次对象。\n\n### 知识点6 ： 常用指令\n\nng-model=\"content.title\"\nng-repeat=\"note in notes\"\nng-repeat=\"note in notes | orderBy:'title' | limitTo:2\" 串联过滤\nng-repeat=\"currency in currencies | filter:{selected:true}\">\nng-click=\"view($index)\" \nng-click=\"editing = true\"\nng-class=\"{active: note.id == content.id}\"\nng-hide=\"editing\"\n$index  ng-repeat中索引 尽量不要使用\nng-disabled=\"editor.$invalid\" 查看表单的验证状态\nng-if=\"content.id\"\n\n\napp.directive('markdown', function () {})\napp.config(function ($stateProvider, $urlRouterProvider) {})   添加视图路由\napp.factory('Currencies', function () {})\nscope.$watch('markdown', function () {}）\n\n{{currency.ticker.last || '0.00'}}\n\n{{   | number:2}}\n\n{{   | date:'mediumTime'}}\n\n[ng-click] {\n  cursor: pointer;\n}","date":"2016-10-05T10:45:12.883Z"},{"id":1417204504666,"title":"买买买","content":"### 马克笔\n\n* 彩色铅笔mac\n* 油笔\n* 粉饼\n* 指甲油 ciate dior butter\n* 护肤\n* 资生堂六角眉笔\n* 修容\n* canmake腮红\n* kiss me 染眉膏\n* Bobbi Brown眉粉\n\n### 护肤\n\n1. 小黄油\n2.  雪花秀\n3. SK-II","date":"2018-08-14T06:22:56.742Z"},{"id":1417007904666,"title":"angularjs的$http","content":"### 关于$http笔记总结\n\n \n语法:\n \n要将区别先弄清$http服务，它是对原生XMLHttpRequest对象的简单封装，是只能接受一个参数的方法，\n这个方法会返回一个promise对象，具有sccess和error两个方法。当然，我们也可以在响应返回时用then\n方法来处理，会得到一个特殊的参数，代表了对象的成功或失败信息，或者可以使用success和error回调\n代替。\n \n \n$http(\n \n).then(function success(resp){\n//响应成功时调用，resp是一个响应对象\n},function error(resp){\n// 响应失败时调用，resp带有错误信息\n}\n);\n可以使用then()函数来处理$http服务的回调\nthen()函数接收的resp（响应对象）包含5个属性：　\n \n1. data（字符串或对象）：响应体,就是后台返回的数据\n2. status:相应http的状态码,如200\n3. headers(函数)：头信息的getter函数，可以接受一个参数，用来获取对应名字的值\n4. config(对象)：生成原始请求的完整设置对象\n5. statusText:相应的http状态文本，如\"ok\"\n \n $http({\n\t url:url,           //请求的url路径\n\t method:method,    //GET/DELETE/HEAD/JSONP/POST/PUT\n\t params:params ,   //转为  ?param1=xx1¶m2=xx2的形式\n\t data: data        //包含了将被当做消息体发送给服务器的数据，通常在POST请求时使用\n}\n}).success(function(response, status, header, config, statusText){\n //成功处理\n}).error(function(data,header,config,status){\n //错误处理\n});\n \nthen写法与success参数是等价的,then方法和success方法的主要区别就是，then方法会接受到完整的响应对象，而\nsuccess则会对响应对象进行析构。\n \n \n \nAngularJS中的简单请求  ---  $http   --- 一个类似jquery的$.ajax的对象，用于异步请求\n  语法：\n \n \n\t\t$http服务的设置对象:\n\t\t\t当我们把$http当成函数来使用时即$http()，需要传入一个对象，这个对象可以包含以下键\n\t\t\t1、method 字符串  表示发送的请求类型 get post jsonp等等\n\t\t\t2、url 字符串 绝对或者相对的URL,请求的目标\n\t\t\t3、params 字符串或对象 会被转化成查询字符串加到URL后面，如果不是字符串会被JSON序列化\n\t\t\t4、data 字符串或者对象 这个对象包含了被当做消息体发送给服务器的数据，一般在POST请求中使用，并且从angular1.3开始可以在POST请求里发送二进制数据\n\t\t\t  如var blob = new Blob({name:’张三’}); $http({method:’get’,url:’/‘,data:blob});\n\t\t\t5、headers 对象 在我们做POST跨域和后台配合的时候就用到了headers，其代表随请求发送的HTTP头字符串\n\t\t\t6、xsrfHeaderName 字符串 保存XSFR令牌的HTTP头的名称\n\t\t\t7、xsrfCookieName  字符串 保存XSFR令牌的cookie的名称\n\t\t\t8、transformRequest 函数或函数组 用来对HTTP请求头和体信息进行转换，并返回转化后的版本，通常用于在请求发送给服务器之前对其序列化\n\t\t\t9、transformResponse 函数或函数组 用来HTTP响应头和响应体信息进行转换，并返回转化后的版本，通常用来反序列化\n\t\t\t10、cache 布尔或缓存对象 如果设置为true angularjs会用默认的$http缓存对GET请求进行缓存\n\t\t\t11、timout 数值或者promise对象，如果为数值那么请求会在指定的毫秒后结束(会跳到失败的error方法里) ，如果为对象那么promise对象在被resolve时请求会被中止，方法执行完毕再执行请求\n\t\t\t12、responseType 字符串 该选项会在请求中设置XMLHttpResponseType属性有以下类型： “”字符串默认，”arraybuffer”(arraybuffer)，”blob”(blob对象)，“document”(HTTP文档)，”json“(从JSON对象解析出来的json字符串)，”text“(字符串)，”moz-blob“(Firefox的接收进度事件)，”moz-chunked-text“(文本流)，”moz-chunked-arraybuffer”(arraybuffer流)\n \n\t\t$http服务的快捷方法\n\t\t\t$http提供了一些快捷方法让我们使用，一共有六个(其实是六种请求模式)\n\t\t\t1、$http.get(url字符串，config可选的配置-对象类型) 返回HttpPromise对象\n\t\t\t2、$http.delete(url字符串，config可选的配置-对象类型) 返回HttpPromise对象\n\t\t\t3、$http.head(url字符串，config可选的配置-对象类型) 返回HttpPromise对象\n\t\t\t4、$http.jsonp(url字符串，config可选的配置-对象类型) 返回HttpPromise对象\n\t\t\t5、$http.post(url字符串，data对象或字符串，config可选的配置-对象类型) 返回HttpPromise对象\n\t\t\t6、$http.put(url字符串，data对象或字符串，config可选的配置-对象类型) 返回HttpPromise对象\n \n \n \n \n \n         $http({\n                 url:url,           //请求的url路径\n                 method:method,    //GET/DELETE/HEAD/JSONP/POST/PUT\n                 params:params ,   //转为  ?param1=xx1¶m2=xx2的形式\n                 data: data        //包含了将被当做消息体发送给服务器的数据，通常在POST请求时使用\n               }\n               }).success(function(response, status, header, config, statusText){\n                 //成功处理\n               }).error(function(data,header,config,status){\n                 //错误处理\n               });\n \n         特别注意：\n                  1.请求参数说明：\n                            url:url,           //请求的url路径\n                            method:method,    //GET/DELETE/HEAD/JSONP/POST/PUT\n                            params:params ,   //转为  ?param1=xx1¶m2=xx2的形式\n                            data: data        //包含了将被当做消息体发送给服务器的数据，通常在POST请求时使用\n \n                  2.响应参数说明：\n                            response     ---  响应体，即：要请求的数据\n                            status       ---  HTTP状态码\n                            header      ---  头信息\n                            config       ---  用来生成原始请求的完整设置对象\n                            statusText   ---  相应的HTTP状态文本\n \n                  3.缓存HTTP请求\n                            默认情况下，$http服务不会对请求进行本地缓存。在发送单独请求时，可通过向$http请求传递一个布尔参数来启用缓存\n                            eg:\n                                  $http.get({'/api/users.json',{cache:true}})\n                                  .success(function(data){   })\n                                  .error(function(data){   })\n                            解析：\n                                 第一次发送请求时，$http服务会向 /api/users.json发送一个GET请求，\n                                 第二次发送同一个GET请求时，$http服务会从缓存中取回请求的结果，而不会真的发送一个HTTP GET请求\n                                 设置启动缓存后，AngularJS默认会使用 $cacheFactory，这个服务在AngularJS启动时自动创建\n                                 如果想要对AngularJS使用的缓存进行更多的自定义控制，可以向请求传入一个自定义的缓存实例代替true。\n \n \n \n      1.GET方式   --- params参数会转为  ?param1=xx1¶m2=xx2的形式\n          1.$http请求：\n                   $http({\n                     url:\"/api/users.json\",\n                     method:'GET',\n                     params:{\n                     'username':'jay'\n                     }\n                   }\n                   }).success(function (response, status, headers, config) {\n                       /*response   -- 成功返回的数据\n                         status     -- 状态码\n                         headers    -- 头信息\n                         config     -- 其他信息\n                       */\n                     }).error(function (response) {\n \n                     }\n                     });\n          2.快捷请求：\n                   $http.get(url, [config])\n                        .success(function(data){})\n                        .error(function(data){});\n \n       2.POST方式\n                   $http({method : 'POST',params : { id:123}, data:{name:'john',age:27}, url : \"/mypath\"})\n                   .success(function(response, status, headers, config){\n                         //do anything what you want;\n                   })\n                   .error(function(response, status, headers, config){\n                        //do  anything what you want;\n                   });\n \n          2.快捷方式：\n                     $http.post(url,  $scope.formData).success(function (response, status, headers, config) {\n                                ......\n                             }).error(function (response) {\n                                ......\n                             });\n \n \n       3.$http提交表单  --- 与Spring MVC交互， 使用这种方式\n \n               通用方式：\n               $http({\n                       method: \"POST\",\n                       url: url,\n                       headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n                       data: $.param($scope.formData)\n                   }).success(function(result){\n \n                   }).error(function(result){\n                   });\n \n               快捷方式：\n               $http.post(url, $scope.formData)\n                    .success(function(result){\n                     })\n                    .error(function(result){\n                     });\n \n                  eg:\n                      var data = {\n                              \"server\":$scope.server,\n                              \"time\":$(\"#time\").val(),\n                              \"day\":day\n                      }\n \n                      $http({\n                          method: \"post\",\n                          url: ctx+'/player/lossPlayer/list.htm',\n                          headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n                          data: $.param(data)\n                      }).success(function(result){\n                          if(result.tip!=undefined){\n                              //当前绑定的数据清空\n                              $scope.players = [];\n                              alert(result.tip);\n                          }else{\n                              console.log(result.json);\n                              $scope.players = $.parseJSON($.parseJSON(result.json).players);\n                          }\n                      });\n \n      4.使用$http指定的方法发送HTTP请求：\n          get(url, [config]);\n          delete(url, [config]);\n          post(url, data, [config]);\n          put(url, data, [config]);\n \n      5.发送jsonp请求：\n          为了发送JSONP请求，url中必须包含JSON_CALLBACK参数， jsonp(url,config) 其中config是可选的\n          eg:\n          var promise=$http.jsonp(\"/api/users.json?callback=JSON_CALLBACK\");","date":"2018-08-14T06:35:59.938Z"},{"id":1416907904666,"title":"最新章节","content":"###勇斗二鬼\n 耳边喧闹的喝彩声与叫骂声充斥着整个斗兽场，或许是因为这次的对手足够强的缘故，场面并没有出现一面倒的情况。\n\n  以往曦的战斗都是一边躲避着妖兽的扑杀，一边寻找着对手的破绽","date":"2018-08-14T06:28:30.581Z"}]